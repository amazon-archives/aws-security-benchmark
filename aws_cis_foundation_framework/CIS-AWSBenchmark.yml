AWSTemplateFormatVersion: 2010-09-09
Description: 'The CIS AWS Foundation Benchmark provides a set of security configuration best practices for AWS'

Metadata:
  'AWS::CloudFormation::Interface':
    ParameterGroups:
      - 
        Label:
            default: CloudWatch Parameters
        Parameters:
          - Email
      - 
        Label:
            default: Config Parameters
        Parameters:
          - DeliveryFrequency

      -
        Label:
            default: Password Policy Parameters
        Parameters:
          - AllowUsersToChangePassword
          - HardExpiry
          - MaxPasswordAge
          - MinimumPasswordLength
          - PasswordReusePrevention
          - RequireLowercaseCharacters
          - RequireNumbers
          - RequireSymbols
          - RequireUppercaseCharacters
      - 
        Label:
            default: CloudTrail Parameters
        Parameters:
          - CloudWatchLogsRetentionInDays
          
Parameters:
  DeliveryChannelS3Prefix:
    Type: String
    Description: The key prefix ('folder') into which to insert config snapshots
    Default: configs
  
  AllowUsersToChangePassword:
    Description: >-
      You can permit all IAM users in your account to use the IAM console to
      change their own passwords.
    Type: String
    Default: true
    AllowedValues:
      - true
      - false
  HardExpiry:
    Description: >-
      You can prevent IAM users from choosing a new password after their current
      password has expired.
    Type: String
    Default: false
    AllowedValues:
      - true
      - false
  MaxPasswordAge:
    Description: >-
      You can set IAM user passwords to be valid for only the specified number
      of days.
    Type: Number
    Default: 90
    ConstraintDescription: 'Must be in the range [0-1095]'
    AllowedValues:
      - 90
      - 120
  MinimumPasswordLength:
    Description: >-
      You can specify the minimum number of characters allowed in an IAM user
      password.
    Type: Number
    Default: 14
    ConstraintDescription: 'Must be in the range [6-128]'
    AllowedValues:
      - 8
      - 14
      - 21
  PasswordReusePrevention:
    Description: >-
      You can prevent IAM users from reusing a specified number of previous
      passwords.
    Type: Number
    Default: 8
    ConstraintDescription: 'Must be in the range [1-24]'
    AllowedValues:
      - 6
      - 8
      - 10
      - 12
  RequireLowercaseCharacters:
    Description: >-
      You can require that IAM user passwords contain at least one lowercase
      character from the ISO basic Latin alphabet (a to z).
    Type: String
    Default: true
    AllowedValues:
      - true
      - false
  RequireNumbers:
    Description: >-
      You can require that IAM user passwords contain at least one numeric
      character (0 to 9).
    Type: String
    Default: true
    AllowedValues:
      - true
      - false
  RequireSymbols:
    Description: >-
      You can require that IAM user passwords contain at least one of the
      following nonalphanumeric characters: ! @ # $ % ^ & * ( ) _ + - = [ ] {} |
      '
    Type: String
    Default: true
    AllowedValues:
      - true
      - false
  RequireUppercaseCharacters:
    Description: >-
      You can require that IAM user passwords contain at least one uppercase
      character from the ISO basic Latin alphabet (A to Z).
    Type: String
    Default: true
    AllowedValues:
      - true
      - false
  
  CloudWatchLogsRetentionInDays:
    Description: The number of days log events are kept in CloudWatch Logs
    Type: Number
    Default: 90
    AllowedValues:
      - 90
      - 180
      - 365
      - 730
      - 2555
  Email:
    Type: String
    Description: Email address to notify when an API activity has triggered an alarm
    AllowedPattern: ([a-zA-Z0-9_\-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)
    ConstraintDescription: Must be a valid email address!
    
Resources:
#===============================================================================================================================
# CloudTrail Setup Section
#===============================================================================================================================
  TrailBucket:
    DeletionPolicy: Retain
    Type: 'AWS::S3::Bucket'
    Properties: {}

  TrailBucketPolicy:
    Type: 'AWS::S3::BucketPolicy'
    Properties:
      Bucket: !Ref TrailBucket
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Sid: AWSCloudTrailAclCheck
            Effect: Allow
            Principal:
              Service: cloudtrail.amazonaws.com
            Action: 's3:GetBucketAcl'
            Resource: !Join 
              - ''
              - - 'arn:aws:s3:::'
                - !Ref TrailBucket
          - Sid: AWSCloudTrailWrite
            Effect: Allow
            Principal:
              Service: cloudtrail.amazonaws.com
            Action: 's3:PutObject'
            Resource: !Join 
              - ''
              - - 'arn:aws:s3:::'
                - !Ref TrailBucket
                - /AWSLogs/
                - !Ref 'AWS::AccountId'
                - /*
            Condition:
              StringEquals:
                's3:x-amz-acl': bucket-owner-full-control
  TrailLogGroup:
    Type: 'AWS::Logs::LogGroup'
    Properties:
      RetentionInDays: !Ref CloudWatchLogsRetentionInDays
  TrailLogGroupRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Sid: AssumeRole1
            Effect: Allow
            Principal:
              Service: cloudtrail.amazonaws.com
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: cloudtrail-policy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Sid: AWSCloudTrailCreateLogStream2014110
                Effect: Allow
                Action: 'logs:CreateLogStream'
                Resource: !GetAtt 
                  - TrailLogGroup
                  - Arn
              - Sid: AWSCloudTrailPutLogEvents20141101
                Effect: Allow
                Action: 'logs:PutLogEvents'
                Resource: !GetAtt 
                  - TrailLogGroup
                  - Arn
  TrailTopic:
    Type: 'AWS::SNS::Topic'
    Properties: {}
  TrailTopicPolicy:
    Type: 'AWS::SNS::TopicPolicy'
    Properties:
      PolicyDocument:
        Version: 2008-10-17
        Statement:
          - Sid: AWSCloudTrailSNSPolicy
            Effect: Allow
            Principal:
              Service: cloudtrail.amazonaws.com
            Resource: '*'
            Action: 'sns:Publish'
      Topics:
        - !Ref TrailTopic
  Trail:
    DependsOn:
      - TrailBucketPolicy
      - TrailTopicPolicy
    Type: 'AWS::CloudTrail::Trail'
    Properties:
      IncludeGlobalServiceEvents: true
      EnableLogFileValidation: true
      IsMultiRegionTrail: true
      IsLogging: true
      S3BucketName: !Ref TrailBucket
      CloudWatchLogsLogGroupArn: !GetAtt 
        - TrailLogGroup
        - Arn
      CloudWatchLogsRoleArn: !GetAtt 
        - TrailLogGroupRole
        - Arn
      SnsTopicName: !GetAtt 
        - TrailTopic
        - TopicName
#===============================================================================================================================
# CloudWatch Setup Section
#===============================================================================================================================
  SecurityGroupChangesMetricFilter:
    Type: 'AWS::Logs::MetricFilter'
    DependsOn: 
        - TrailLogGroup
    Properties:
      LogGroupName: !Ref TrailLogGroup
      FilterPattern: >-
        { ($.eventName = AuthorizeSecurityGroupIngress) || ($.eventName =
        AuthorizeSecurityGroupEgress) || ($.eventName =
        RevokeSecurityGroupIngress) || ($.eventName = RevokeSecurityGroupEgress)
        || ($.eventName = CreateSecurityGroup) || ($.eventName =
        DeleteSecurityGroup) }
      MetricTransformations:
        - MetricNamespace: CloudTrailMetrics
          MetricName: SecurityGroupEventCount
          MetricValue: '1'
  UnauthorizedApiCallsAlarm:
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      AlarmDescription: log metric filter and alarm for unauthorized API calls
      MetricName: UnauthorizedApiCalls
      Namespace: LogMetrics
      Statistic: Sum
      Period: '300'
      EvaluationPeriods: '1'
      Threshold: '1'
      AlarmActions:
        - !Ref AlarmNotificationTopic
      ComparisonOperator: GreaterThanThreshold
  UnauthorizedApiCallsFilter:
    Type: 'AWS::Logs::MetricFilter'
    DependsOn: 
        - TrailLogGroup
    Properties:
      LogGroupName: !Ref TrailLogGroup
      FilterPattern: >-
        { ($.errorCode = "*UnauthorizedOperation") || ($.errorCode =
        "AccessDenied*") }
      MetricTransformations:
        - MetricValue: '1'
          MetricNamespace: LogMetrics
          MetricName: UnauthorizedApiCalls
  NoMfaConsoleLoginsAlarm:
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      AlarmDescription: Management Console sign-in without MFA
      MetricName: NoMfaConsoleLogins
      Namespace: LogMetrics
      Statistic: Sum
      Period: '300'
      EvaluationPeriods: '1'
      Threshold: '1'
      AlarmActions:
        - !Ref AlarmNotificationTopic
      ComparisonOperator: GreaterThanThreshold
  NoMfaConsoleLoginsFilter:
    Type: 'AWS::Logs::MetricFilter'
    DependsOn: 
        - TrailLogGroup
    Properties:
      LogGroupName: !Ref TrailLogGroup
      FilterPattern: >-
        { $.userIdentity.sessionContext.attributes.mfaAuthenticated != "true" &&
        $.userIdentity.invokedBy = "signin.amazonaws.com" }
      MetricTransformations:
        - MetricValue: '1'
          MetricNamespace: LogMetrics
          MetricName: NoMfaConsoleLogins
  RootAccountLoginsAlarm:
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      AlarmDescription: Usage of 'root' account
      MetricName: RootAccountLogins
      Namespace: LogMetrics
      Statistic: Sum
      Period: '300'
      EvaluationPeriods: '1'
      Threshold: '1'
      AlarmActions:
        - !Ref AlarmNotificationTopic
      ComparisonOperator: GreaterThanThreshold
  RootAccountLoginsFilter:
    Type: 'AWS::Logs::MetricFilter'
    DependsOn: 
        - TrailLogGroup
    Properties:
      LogGroupName: !Ref TrailLogGroup
      FilterPattern: >-
        { $.userIdentity.type = "Root" && $.userIdentity.invokedBy NOT EXISTS &&
        $.eventType != "AwsServiceEvent" }
      MetricTransformations:
        - MetricValue: '1'
          MetricNamespace: LogMetrics
          MetricName: RootAccountLogins
  IamPolicyChangesAlarm:
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      AlarmDescription: IAM policy changes
      MetricName: IamPolicyChanges
      Namespace: LogMetrics
      Statistic: Sum
      Period: '300'
      EvaluationPeriods: '1'
      Threshold: '1'
      AlarmActions:
        - !Ref AlarmNotificationTopic
      ComparisonOperator: GreaterThanThreshold
  IamPolicyChangesFilter:
    Type: 'AWS::Logs::MetricFilter'
    DependsOn: 
        - TrailLogGroup
    Properties:
      LogGroupName: !Ref TrailLogGroup
      FilterPattern: >-
        {($.eventName=DeleteGroupPolicy)||($.eventName=DeleteRolePolicy)||($.eventName=DeleteUserPolicy)||($.eventName=PutGroupPolicy)||($.eventName=PutRolePolicy)||($.eventName=PutUserPolicy)||($.eventName=CreatePolicy)||($.eventName=DeletePolicy)||($.eventName=CreatePolicyVersion)||($.eventName=DeletePolicyVersion)||($.eventName=AttachRolePolicy)||($.eventName=DetachRolePolicy)||($.eventName=AttachUserPolicy)||($.eventName=DetachUserPolicy)||($.eventName=AttachGroupPolicy)||($.eventName=DetachGroupPolicy)}
      MetricTransformations:
        - MetricValue: '1'
          MetricNamespace: LogMetrics
          MetricName: IamPolicyChanges
  CloudTrailConfigurationChangesAlarm:
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      AlarmDescription: CloudTrail configuration changes
      MetricName: CloudTrailConfigurationChanges
      Namespace: LogMetrics
      Statistic: Sum
      Period: '300'
      EvaluationPeriods: '1'
      Threshold: '1'
      AlarmActions:
        - !Ref AlarmNotificationTopic
      ComparisonOperator: GreaterThanThreshold
  CloudTrailConfigurationChangesFilter:
    Type: 'AWS::Logs::MetricFilter'
    DependsOn: 
        - TrailLogGroup
    Properties:
      LogGroupName: !Ref TrailLogGroup
      FilterPattern: >-
        { ($.eventName = CreateTrail) ||($.eventName = UpdateTrail) ||
        ($.eventName = DeleteTrail) || ($.eventName = StartLogging) ||
        ($.eventName = StopLogging) }
      MetricTransformations:
        - MetricValue: '1'
          MetricNamespace: LogMetrics
          MetricName: CloudTrailConfigurationChanges
  FailedConsoleLoginsAlarm:
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      AlarmDescription: AWS Management Console authentication failures
      MetricName: FailedConsoleLogins
      Namespace: LogMetrics
      Statistic: Sum
      Period: '300'
      EvaluationPeriods: '1'
      Threshold: '3'
      AlarmActions:
        - !Ref AlarmNotificationTopic
      ComparisonOperator: GreaterThanThreshold
  FailedConsoleLoginsFilter:
    Type: 'AWS::Logs::MetricFilter'
    DependsOn: 
        - TrailLogGroup
    Properties:
      LogGroupName: !Ref TrailLogGroup
      FilterPattern: >-
        { ($.eventName = ConsoleLogin) && ($.errorMessage = "Failed
        authentication") }
      MetricTransformations:
        - MetricValue: '1'
          MetricNamespace: LogMetrics
          MetricName: FailedConsoleLogins
  DisabledOrDeletedCmksAlarm:
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      AlarmDescription: Disabling or scheduled deletion of customer created CMKs
      MetricName: DisabledOrDeletedCmks
      Namespace: LogMetrics
      Statistic: Sum
      Period: '300'
      EvaluationPeriods: '1'
      Threshold: '1'
      AlarmActions:
        - !Ref AlarmNotificationTopic
      ComparisonOperator: GreaterThanThreshold
  DisabledOrDeletedCmksFilter:
    Type: 'AWS::Logs::MetricFilter'
    DependsOn: 
        - TrailLogGroup
    Properties:
      LogGroupName: !Ref TrailLogGroup
      FilterPattern: >-
        {($.eventSource = kms.amazonaws.com) &&
        (($.eventName=DisableKey)||($.eventName=ScheduleKeyDeletion))}
      MetricTransformations:
        - MetricValue: '1'
          MetricNamespace: LogMetrics
          MetricName: DisabledOrDeletedCmks
  S3BucketPolicyChangesAlarm:
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      AlarmDescription: S3 bucket policy changes
      MetricName: S3BucketPolicyChanges
      Namespace: LogMetrics
      Statistic: Sum
      Period: '300'
      EvaluationPeriods: '1'
      Threshold: '1'
      AlarmActions:
        - !Ref AlarmNotificationTopic
      ComparisonOperator: GreaterThanThreshold
  S3BucketPolicyChangesFilter:
    Type: 'AWS::Logs::MetricFilter'
    DependsOn: 
        - TrailLogGroup
    Properties:
      LogGroupName: !Ref TrailLogGroup
      FilterPattern: >-
        { ($.eventSource = s3.amazonaws.com) && (($.eventName = PutBucketAcl) ||
        ($.eventName = PutBucketPolicy) || ($.eventName = PutBucketCors) ||
        ($.eventName = PutBucketLifecycle) || ($.eventName =
        PutBucketReplication) || ($.eventName = DeleteBucketPolicy) ||
        ($.eventName = DeleteBucketCors) || ($.eventName =
        DeleteBucketLifecycle) || ($.eventName = DeleteBucketReplication)) }
      MetricTransformations:
        - MetricValue: '1'
          MetricNamespace: LogMetrics
          MetricName: S3BucketPolicyChanges
  AwsConfigChangesAlarm:
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      AlarmDescription: AWS Config configuration changes
      MetricName: AwsConfigChanges
      Namespace: LogMetrics
      Statistic: Sum
      Period: '300'
      EvaluationPeriods: '1'
      Threshold: '1'
      AlarmActions:
        - !Ref AlarmNotificationTopic
      ComparisonOperator: GreaterThanThreshold
  AwsConfigChangesFilter:
    Type: 'AWS::Logs::MetricFilter'
    DependsOn: 
        - TrailLogGroup
    Properties:
      LogGroupName: !Ref TrailLogGroup
      FilterPattern: >-
        {($.eventSource = config.amazonaws.com) &&
        (($.eventName=StopConfigurationRecorder)||($.eventName=DeleteDeliveryChannel)||($.eventName=PutDeliveryChannel)||($.eventName=PutConfigurationRecorder))}
      MetricTransformations:
        - MetricValue: '1'
          MetricNamespace: LogMetrics
          MetricName: AwsConfigChanges
  SecurityGroupChangesAlarm:
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      AlarmDescription: Security group changes
      MetricName: SecurityGroupChanges
      Namespace: LogMetrics
      Statistic: Sum
      Period: '300'
      EvaluationPeriods: '1'
      Threshold: '1'
      AlarmActions:
        - !Ref AlarmNotificationTopic
      ComparisonOperator: GreaterThanThreshold
  SecurityGroupChangesFilter:
    Type: 'AWS::Logs::MetricFilter'
    DependsOn: 
        - TrailLogGroup
    Properties:
      LogGroupName: !Ref TrailLogGroup
      FilterPattern: >-
        { ($.eventName = AuthorizeSecurityGroupIngress) || ($.eventName =
        AuthorizeSecurityGroupEgress) || ($.eventName =
        RevokeSecurityGroupIngress) || ($.eventName = RevokeSecurityGroupEgress)
        || ($.eventName = CreateSecurityGroup) || ($.eventName =
        DeleteSecurityGroup)}
      MetricTransformations:
        - MetricValue: '1'
          MetricNamespace: LogMetrics
          MetricName: SecurityGroupChanges
  NetworkAccessControlListChangesAlarm:
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      AlarmDescription: Changes to Network Access Control Lists
      MetricName: NetworkAccessControlListChanges
      Namespace: LogMetrics
      Statistic: Sum
      Period: '300'
      EvaluationPeriods: '1'
      Threshold: '1'
      AlarmActions:
        - !Ref AlarmNotificationTopic
      ComparisonOperator: GreaterThanThreshold
  NetworkAccessControlListChangesFilter:
    Type: 'AWS::Logs::MetricFilter'
    DependsOn: 
        - TrailLogGroup
    Properties:
      LogGroupName: !Ref TrailLogGroup
      FilterPattern: >-
        { ($.eventName = CreateNetworkAcl) || ($.eventName =
        CreateNetworkAclEntry) || ($.eventName = DeleteNetworkAcl) ||
        ($.eventName = DeleteNetworkAclEntry) || ($.eventName =
        ReplaceNetworkAclEntry) || ($.eventName = ReplaceNetworkAclAssociation)
        }
      MetricTransformations:
        - MetricValue: '1'
          MetricNamespace: LogMetrics
          MetricName: NetworkAccessControlListChanges
  NetworkGatewayChangesAlarm:
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      AlarmDescription: Changes to network gateways
      MetricName: NetworkGatewayChanges
      Namespace: LogMetrics
      Statistic: Sum
      Period: '300'
      EvaluationPeriods: '1'
      Threshold: '1'
      AlarmActions:
        - !Ref AlarmNotificationTopic
      ComparisonOperator: GreaterThanThreshold
  NetworkGatewayChangesFilter:
    Type: 'AWS::Logs::MetricFilter'
    DependsOn: 
        - TrailLogGroup
    Properties:
      LogGroupName: !Ref TrailLogGroup
      FilterPattern: >-
        { ($.eventName = CreateCustomerGateway) || ($.eventName =
        DeleteCustomerGateway) || ($.eventName = AttachInternetGateway) ||
        ($.eventName = CreateInternetGateway) || ($.eventName =
        DeleteInternetGateway) || ($.eventName = DetachInternetGateway) }
      MetricTransformations:
        - MetricValue: '1'
          MetricNamespace: LogMetrics
          MetricName: NetworkGatewayChanges
  NetworkVPCChangesAlarm:
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      AlarmDescription: VPC changes
      MetricName: NetworkVPCChanges
      Namespace: LogMetrics
      Statistic: Sum
      Period: '300'
      EvaluationPeriods: '1'
      Threshold: '1'
      AlarmActions:
        - !Ref AlarmNotificationTopic
      ComparisonOperator: GreaterThanThreshold
  NetworkVPCChangesFilter:
    Type: 'AWS::Logs::MetricFilter'
    DependsOn: 
        - TrailLogGroup
    Properties:
      LogGroupName: !Ref TrailLogGroup
      FilterPattern: >-
        { ($.eventName = CreateVpc) || ($.eventName = DeleteVpc) || ($.eventName
        = ModifyVpcAttribute) || ($.eventName = AcceptVpcPeeringConnection) ||
        ($.eventName = CreateVpcPeeringConnection) || ($.eventName =
        DeleteVpcPeeringConnection) || ($.eventName =
        RejectVpcPeeringConnection) || ($.eventName = AttachClassicLinkVpc) ||
        ($.eventName = DetachClassicLinkVpc) || ($.eventName =
        DisableVpcClassicLink) || ($.eventName = EnableVpcClassicLink) }
      MetricTransformations:
        - MetricValue: '1'
          MetricNamespace: LogMetrics
          MetricName: NetworkVPCChanges
  AlarmNotificationTopic:
    Type: 'AWS::SNS::Topic'
    Properties:
      Subscription:
        - Endpoint: !Ref Email
          Protocol: email
#===============================================================================================================================
# Config Setup Section
#===============================================================================================================================
  ConfigTopic:
    Type: 'AWS::SNS::Topic'
    Properties: {}
  DeliveryChannelS3Bucket:
    DeletionPolicy: Retain
    Type: 'AWS::S3::Bucket'
    Properties: {}
  DeliveryChannel:
    Type: 'AWS::Config::DeliveryChannel'
    Properties:
      Name: !GetAtt 
        - ConfigurationRecorderSanitisationResults
        - ConfigurationRecorder
      S3BucketName: !Ref DeliveryChannelS3Bucket
      S3KeyPrefix: !Ref DeliveryChannelS3Prefix
      SnsTopicARN: !Ref ConfigTopic
    DependsOn:
      - AWSConfigRole
      - ConfigurationRecorderSanitisationResults
  ConfigurationRecorder:
    Type: 'AWS::Config::ConfigurationRecorder'
    Properties:
      Name: !GetAtt 
        - ConfigurationRecorderSanitisationResults
        - ConfigurationRecorder
      RecordingGroup:
        AllSupported: true
        IncludeGlobalResourceTypes: true
      RoleARN: !GetAtt 
        - AWSConfigRole
        - Arn
    DependsOn:
      - AWSConfigRole
  AWSConfigRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - config.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSConfigRole'
      Policies:
        - PolicyName: !Join 
            - ''
            - - AWSConfigDeliveryPermissions-
              - !Ref 'AWS::Region'
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Sid: Stmt1460390265000
                Effect: Allow
                Action:
                  - 'config:Put*'
                Resource:
                  - '*'
              - Sid: AWSConfigSNSPolicy20150201
                Action:
                  - 'SNS:Publish'
                Effect: Allow
                Resource: !Ref ConfigTopic
              - Effect: Allow
                Action:
                  - 's3:PutObject*'
                Resource:
                  - !Join 
                    - ''
                    - - 'arn:aws:s3:::'
                      - !Ref DeliveryChannelS3Bucket
                      - /
                      - !Ref DeliveryChannelS3Prefix
                      - /AWSLogs/*
              - Effect: Allow
                Action:
                  - 's3:GetBucketAcl'
                Resource: !Join 
                  - ''
                  - - 'arn:aws:s3:::'
                    - !Ref DeliveryChannelS3Bucket
  ConfigurationRecorderSanitisationResults:
    Type: 'Custom::ConfigurationRecorderSanitisationResults'
    Properties:
      ServiceToken: !GetAtt 
        - ConfigurationRecorderSanitiser
        - Arn
      RoleARN: !GetAtt 
        - AWSConfigRole
        - Arn
  ConfigurationRecorderSanitiser:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        ZipFile: !Join 
          - |+

          - - // dependencies
            - var AWS = require('aws-sdk');
            - var response = require('cfn-response');
            - var configservice = new AWS.ConfigService();
            - 'exports.handler = function(event, context, callback) {'
            - '    '
            - '    console.log(''Checking if a configuration recorder exists'')'
            - '    configservice.describeConfigurationRecorders(null, function(err, data) {'
            - '      if (err) console.log(err, err.stack); // an error occurred'
            - '      else{'
            - '        console.log(''Configuration recorders: '' + JSON.stringify(data));'
            - '        if(data.ConfigurationRecorders.length > 0){'
            - '            var configurationRecorders = data'
            - '            var params = {'
            - '              ConfigurationRecorder: {'
            - '                name: configurationRecorders.ConfigurationRecorders[0].name,'
            - '                recordingGroup: configurationRecorders.ConfigurationRecorders[0].recordingGroup,'
            - '                roleARN: event.ResourceProperties.RoleARN'
            - '              }'
            - '            };'
            - '            console.log(''Setting the Configuration Recorder\''s IAM role to the one created by our CFN stack: '' + event.ResourceProperties.RoleARN)'
            - '            configservice.putConfigurationRecorder(params, function(err, data) {'
            - '            if (err) console.log(err, err.stack); // an error occurred'
            - '            else {'
            - '            console.log(''Found Configuration Recoder: '' + configurationRecorders.ConfigurationRecorders[0].name);'
            - '            console.log(''Checking for the existence of a Delivery Channel'')'
            - '            configservice.describeDeliveryChannels(null, function(err, data) {'
            - '                if (err) console.log(''failed to get delivery channels: '', err, err.stack); // an error occurred'
            - '                else{'
            - '                    if(data.DeliveryChannels.length > 0){'
            - '                        console.log(''There is a Delivery Channel, let\''s delete it!'')'
            - '                        deliveryChannels = data'
            - '                        console.log(''Making sure the Delivery Recorder is stopped'')'
            - '                        var params = { ConfigurationRecorderName: configurationRecorders.ConfigurationRecorders[0].name};'
            - '                        configservice.stopConfigurationRecorder(params, function(err, data) {'
            - '                          if (err) console.log(err, err.stack); // an error occurred'
            - '                          else{'
            - '                               console.log(''success in stopping: '', data);'
            - '                               console.log(''Deleting Delivery Channel'')'
            - '                               params = { DeliveryChannelName: deliveryChannels.DeliveryChannels[0].name }'
            - '                               configservice.deleteDeliveryChannel(params, function(err, data) {'
            - '                                  if (err) console.log(err, err.stack); // an error occurred'
            - '                                  else  {'
            - '                                       console.log(''Successfully deleted Delivery Channel'')    // successful response'
            - '                                       // Return the name of the configuration recorder as one exists'
            - '                                       response.send(event, context, response.SUCCESS, {''ConfigurationRecorder'':configurationRecorders.ConfigurationRecorders[0].name});'
            - '                                   }'
            - '                                });'
            - '                          }   '
            - '                        }); '
            - '                    }else{'
            - '                        console.log(''No Delivery Channel to Delete'');'
            - '                        // Return the name of the configuration recorder as one exists'
            - '                        response.send(event, context, response.SUCCESS, {''ConfigurationRecorder'':configurationRecorders.ConfigurationRecorders[0].name});'
            - '                    }'
            - '                }'
            - '              });'
            - '            }'
            - '            });'
            - '        }else{'
            - '            console.log(''No Configuration Records exist, returning default recorder name'')'
            - '            response.send(event, context, response.SUCCESS, {''ConfigurationRecorder'':''defaultConfigurationRecorder''});'
            - '        }'
            - '      }   '
            - '    });'
            - '};'
      Handler: index.handler
      Runtime: nodejs4.3
      Timeout: '30'
      Role: !GetAtt 
        - LambdaExecutionRole
        - Arn
  LambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Path: /
      Policies:
        - PolicyName: root
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Sid: Stmt1460475162000
                Effect: Allow
                Action:
                  - 'iam:PassRole'
                Resource:
                  - !GetAtt 
                    - AWSConfigRole
                    - Arn
              - Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: 'arn:aws:logs:*:*:*'
              - Effect: Allow
                Action:
                  - 'config:DeleteDeliveryChannel'
                  - 'config:DescribeConfigurationRecorders'
                  - 'config:DescribeDeliveryChannels'
                  - 'config:PutConfigurationRecorder'
                  - 'config:StopConfigurationRecorder'
                Resource:
                  - '*'

#===============================================================================================================================
# Config Rules Section
#===============================================================================================================================
  EvaluateMFAAllUsersLambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      FunctionName: !GetAtt 
        - FunctionForEvaluateMFAAllUsers
        - Arn
      Action: 'lambda:InvokeFunction'
      Principal: config.amazonaws.com
  FunctionForEvaluateMFAAllUsers:
    Type: 'AWS::Lambda::Function'
    DependsOn:
      - MasterConfigRole
    Properties:
      Code:
        ZipFile: !Join 
          - |+

          - - import json
            - import boto3
            - 'APPLICABLE_RESOURCES = [''AWS::IAM::User'']'
            - 'def evaluate_compliance(configuration_item):'
            - '    if configuration_item[''resourceType''] not in APPLICABLE_RESOURCES:'
            - '        return ''NOT_APPLICABLE'''
            - '    user_name = configuration_item[''configuration''][''userName'']'
            - '    iam = boto3.resource(''iam'')'
            - '    client = boto3.client(''iam'')'
            - '    user=iam.User(user_name)'
            - '    mfa = client.list_mfa_devices(UserName=user_name)'
            - '    if user.password_last_used is None:'
            - '        return ''NOT_APPLICABLE'''
            - '    elif len(mfa[''MFADevices'']) > 0:'
            - '        return ''COMPLIANT'''
            - '    else:'
            - '        return ''NON_COMPLIANT'''
            - 'def lambda_handler(event, context):'
            - '    invoking_event = json.loads(event[''invokingEvent''])'
            - '    configuration_item = invoking_event[''configurationItem'']'
            - '    result_token = ''No token found.'''
            - '    if ''resultToken'' in event:'
            - '        result_token = event[''resultToken'']'
            - '    config = boto3.client(''config'')'
            - '    config.put_evaluations('
            - '        Evaluations=['
            - '            {'
            - '                ''ComplianceResourceType'':'
            - '                    configuration_item[''resourceType''],'
            - '                ''ComplianceResourceId'':'
            - '                    configuration_item[''resourceId''],'
            - '                ''ComplianceType'':'
            - '                    evaluate_compliance(configuration_item),'
            - '                ''Annotation'':'
            - '                    ''The compliance status checks for users with password to have MFA enabled.'','
            - '                ''OrderingTimestamp'':'
            - '                    configuration_item[''configurationItemCaptureTime'']'
            - '            },'
            - '        ],'
            - '        ResultToken=result_token'
            - '    )'
      Handler: index.lambda_handler
      Runtime: python2.7
      Timeout: '300'
      Role: !GetAtt 
        - MasterConfigRole
        - Arn
  ConfigRuleForEvaluateMFAAllUsers:
    Type: 'AWS::Config::ConfigRule'
    Properties:
      ConfigRuleName: EvaluateMFAAllUsers
      Description: >-
        ConfigRule for CIS 1.2 - Ensure multi-factor authentication (MFA) is
        enabled for all IAM users that have a password (Scored)
      Scope:
        ComplianceResourceTypes:
          - 'AWS::IAM::User'
      Source:
        Owner: CUSTOM_LAMBDA
        SourceDetails:
          - EventSource: aws.config
            MessageType: ConfigurationItemChangeNotification
        SourceIdentifier: !GetAtt 
          - FunctionForEvaluateMFAAllUsers
          - Arn
    DependsOn: 
        - EvaluateMFAAllUsersLambdaInvokePermission
        - DeliveryChannel
  MasterConfigRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/AmazonEC2ReadOnlyAccess'
        - 'arn:aws:iam::aws:policy/AWSCloudTrailReadOnlyAccess'
        - 'arn:aws:iam::aws:policy/IAMReadOnlyAccess'
        - 'arn:aws:iam::aws:policy/service-role/AWSConfigRulesExecutionRole'
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
        - PolicyName: KmsReadOnly
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 'kms:GetKeyRotationStatus'
                  - 'kms:ListKeys'
                Resource: '*'
        - PolicyName: S3ReadOnly
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 's3:GetBucketAcl'
                  - 's3:GetBucketLogging'
                Resource: '*'
  EvaluateRootAccountLambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      FunctionName: !GetAtt 
        - FunctionForEvaluateRootAccountRule
        - Arn
      Action: 'lambda:InvokeFunction'
      Principal: config.amazonaws.com
  FunctionForEvaluateRootAccountRule:
    Type: 'AWS::Lambda::Function'
    DependsOn:
      - MasterConfigRole
    Properties:
      FunctionName: EvaluateRootAccount
      Code:
        ZipFile: !Join 
          - |+

          - - >-
              #==================================================================================================
            - '# Function: EvaluateRootAccountSecurityProperties'
            - '# Purpose:  Evaluates the root account for security properties'
            - >-
              #==================================================================================================
            - import json
            - import boto3
            - import datetime
            - FIELD_ACCESS_KEY_1_ACTIVE = 8
            - FIELD_ACCESS_KEY_2_ACTIVE = 13
            - 'def lambda_handler(event, context):'
            - '    is_compliant = True'
            - '    annotation = '''''
            - '    invoking_event = json.loads(event[''invokingEvent''])'
            - '    result_token = ''No token found.'''
            - '    if ''resultToken'' in event: result_token = event[''resultToken'']'
            - '    client = boto3.client(''iam'')'
            - '    # Determine whether the root account has MFA enabled.'
            - '    summary = client.get_account_summary()[''SummaryMap'']'
            - '    if ''AccountMFAEnabled'' in summary and summary[''AccountMFAEnabled''] == 1:'
            - '        is_compliant = is_compliant and True'
            - '        annotation = annotation + '' The root account has MFA enabled.'''
            - '    else:'
            - '        is_compliant = is_compliant and False'
            - '        annotation = annotation + '' The root account does NOT have MFA enabled.'''
            - '    # Determine whether the root account uses hardware-based MFA.'
            - '    mfa_devices = client.list_virtual_mfa_devices()[''VirtualMFADevices'']'
            - '    for mfa_device in mfa_devices:'
            - '        if not ''SerialNumber'' in mfa_device:'
            - '            is_compliant = is_compliant and True'
            - '            annotation = annotation + '' The root account has hardware-based MFA enabled.'''
            - '        else:'
            - '            is_compliant = is_compliant and False'
            - '            annotation = annotation + '' The root account does NOT have hardware-based MFA enabled.'''
            - '    # Determine whether the root account has active access keys.'
            - '    # The credential report will contain comma-separated values, so transform the users into a list.'
            - '    response = client.generate_credential_report()'
            - '    content = client.get_credential_report()[''Content'']'
            - '    users = content.splitlines()'
            - '    # Look for the ''<root_account>'' user value and determine whether acccess keys are active.'
            - '    for user in users:'
            - '        if ''<root_account>'' in user:'
            - '            user_values = user.split('','')'
            - '            if user_values[FIELD_ACCESS_KEY_1_ACTIVE].lower() == ''false'' and user_values[FIELD_ACCESS_KEY_2_ACTIVE].lower() == ''false'':'
            - '                is_compliant = is_compliant and True'
            - '                annotation = annotation + '' The root account does NOT have active access keys associated with it.'''
            - '            else:'
            - '                is_compliant = is_compliant and False'
            - '                annotation = annotation + '' The root account HAS active access keys associated with it.'''
            - '            break'
            - '    config = boto3.client(''config'')'
            - '    config.put_evaluations('
            - '        Evaluations=['
            - '            {'
            - '                ''ComplianceResourceType'': ''AWS::::Account'','
            - '                ''ComplianceResourceId'': ''Root'','
            - '                ''ComplianceType'': ''COMPLIANT'' if is_compliant else ''NON_COMPLIANT'','
            - '                ''Annotation'': annotation,'
            - '                ''OrderingTimestamp'': datetime.datetime.now(),'
            - '            },'
            - '        ],'
            - '        ResultToken=result_token'
            - '    )'
      Description: >-
        Evaluates the security properties of the root account - CIS 1.12, 1.13,
        1.14
      Handler: index.lambda_handler
      MemorySize: 1024
      Role: !GetAtt 
        - MasterConfigRole
        - Arn
      Runtime: python2.7
      Timeout: 10
  ConfigRuleForEvaluateRootAccount:
    Type: 'AWS::Config::ConfigRule'
    DependsOn: 
        - EvaluateRootAccountLambdaInvokePermission
        - DeliveryChannel
    Properties:
      ConfigRuleName: RootAccoutMustHaveMfaEnabled
      Description: >-
        ConfigRule to evaluate the root account for CIS 1.12 - Ensure no root
        account access key exists (Scored) 
         CIS 1.13 - Ensure  MFA is enabled for the 'root' account (Scored) 
         CIS 1.14 - Ensure hardware MFA is enabled for the 'root' account (Scored)
      Source:
        Owner: CUSTOM_LAMBDA
        SourceDetails:
          - EventSource: aws.config
            MessageType: ConfigurationItemChangeNotification
        SourceIdentifier: !GetAtt 
          - FunctionForEvaluateRootAccountRule
          - Arn
  EvaluateUserPolicyAssociationLambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    DependsOn: FunctionForEvaluateUserPolicyAssociationRule
    Properties:
      FunctionName: !GetAtt 
        - FunctionForEvaluateUserPolicyAssociationRule
        - Arn
      Action: 'lambda:InvokeFunction'
      Principal: config.amazonaws.com
  FunctionForEvaluateUserPolicyAssociationRule:
    Type: 'AWS::Lambda::Function'
    DependsOn:
      - MasterConfigRole
    Properties:
      FunctionName: EvaluateUserPolicyAssociations
      Description: >-
        Evaluates whether users have policies associated with them. Users should
        inherit permissions from groups instead.
      Code:
        ZipFile: !Join 
          - |+

          - - >-
              #==================================================================================================
            - '# Function: EvaluateUserPolicyAssociations'
            - >-
              # Purpose:  Evaluates whether users have policies associated with
              them. Users should inherit permissions from groups instead.
            - >-
              #==================================================================================================
            - import json
            - import boto3
            - 'APPLICABLE_RESOURCES = [''AWS::IAM::User'']'
            - annotation = ''
            - 'def evaluate_compliance(configuration_item):'
            - '    global annotation'
            - '    annotation='''''
            - '    if configuration_item[''resourceType''] not in APPLICABLE_RESOURCES:'
            - '        return ''NOT_APPLICABLE'''
            - '    user_name = configuration_item[''resourceName'']'
            - '    iam = boto3.client(''iam'')'
            - '    if iam.list_user_policies(UserName=user_name)[''PolicyNames'']:'
            - '        annotation=annotation + ''The user has inline policies attached! '''
            - '        return ''NON_COMPLIANT'''
            - '    elif iam.list_attached_user_policies(UserName=user_name)[''AttachedPolicies'']:'
            - '        annotation=annotation + ''The user has managed policies attached! '''
            - '        return ''NON_COMPLIANT'''
            - '    else:'
            - '        annotation=annotation + ''The user does not have inline or managed policies attached! '''
            - '        return ''COMPLIANT'''
            - 'def lambda_handler(event, context):'
            - '    invoking_event = json.loads(event[''invokingEvent''])'
            - '    configuration_item = invoking_event[''configurationItem'']'
            - '    result_token = ''No token found.'''
            - '    if ''resultToken'' in event: result_token = event[''resultToken'']'
            - '    config = boto3.client(''config'')'
            - '    config.put_evaluations('
            - '        Evaluations=['
            - '            {'
            - '                ''ComplianceResourceType'': configuration_item[''resourceType''],'
            - '                ''ComplianceResourceId'': configuration_item[''resourceId''],'
            - '                ''ComplianceType'': evaluate_compliance(configuration_item),'
            - '                ''Annotation'':annotation,'
            - '                ''OrderingTimestamp'': configuration_item[''configurationItemCaptureTime'']'
            - '            },'
            - '        ],'
            - '        ResultToken=result_token'
            - '    )'
      Handler: index.lambda_handler
      MemorySize: 1024
      Role: !GetAtt 
        - MasterConfigRole
        - Arn
      Runtime: python2.7
      Timeout: 10
  ConfigRuleForEvaluateUserPolicyAssociations:
    Type: 'AWS::Config::ConfigRule'
    DependsOn:
      - FunctionForEvaluateUserPolicyAssociationRule
      - EvaluateUserPolicyAssociationLambdaInvokePermission
      - DeliveryChannel
    Properties:
      ConfigRuleName: UsersMustNotHaveAssociatedPolicies
      Description: >-
        ConfigRule to evaluate whether users have policies associated with them;
        users should inherit permissions from groups instead - CIS 1.16 - Ensure
        IAM policies are attached only to groups or roles (Scored)
      Scope:
        ComplianceResourceTypes:
          - 'AWS::IAM::User'
      Source:
        Owner: CUSTOM_LAMBDA
        SourceDetails:
          - EventSource: aws.config
            MessageType: ConfigurationItemChangeNotification
        SourceIdentifier: !GetAtt 
          - FunctionForEvaluateUserPolicyAssociationRule
          - Arn
  EvaluateAwsSupportAccessPolicyLambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    DependsOn: FunctionForEvaluateAwsSupportAccessPolicy
    Properties:
      FunctionName: !GetAtt 
        - FunctionForEvaluateAwsSupportAccessPolicy
        - Arn
      Action: 'lambda:InvokeFunction'
      Principal: config.amazonaws.com
  FunctionForEvaluateAwsSupportAccessPolicy:
    Type: 'AWS::Lambda::Function'
    DependsOn:
      - MasterConfigRole
    Properties:
      FunctionName: EvaluateAwsSupportAccessPolicy
      Description: >-
        Evaluates whether users / groups / roles have the 'AWSSupportAccess'
        policy associated.
      Code:
        ZipFile: !Join 
          - |+

          - - import boto3
            - import json
            - 'def evaluate_compliance(resource_type):'
            - '   return_value = ''COMPLIANT'''
            - '   client = boto3.client(''iam'')'
            - '   response = client.list_entities_for_policy(PolicyArn=''arn:aws:iam::aws:policy/AWSSupportAccess'')'
            - '   if (resource_type) == ''user'' and len(response[''PolicyUsers'']) == 0:'
            - '       return_value = ''NON_COMPLIANT'''
            - '   elif (resource_type) == ''group'' and len(response[''PolicyGroups'']) == 0:'
            - '       return_value = ''NON_COMPLIANT'''
            - '   elif (resource_type) == ''role'' and len(response[''PolicyRoles'']) == 0:'
            - '       return_value = ''NON_COMPLIANT'''
            - '   else:'
            - '       return_value = ''COMPLIANT'''
            - '   return return_value'
            - 'def lambda_handler(event, context):'
            - '   invoking_event = json.loads(event[''invokingEvent''])'
            - '   config = boto3.client(''config'')'
            - '   response = config.put_evaluations('
            - '       Evaluations=['
            - '           {'
            - '               ''ComplianceResourceType'': ''AWS::IAM::User'','
            - '               ''ComplianceResourceId'': ''NA'','
            - '               ''ComplianceType'': evaluate_compliance(''user''),'
            - '               ''Annotation'': ''Checks to see if AWSSupportAccess policy is assigned to IAM User'','
            - '               ''OrderingTimestamp'': invoking_event[''notificationCreationTime'']'
            - '           },'
            - '           {'
            - '               ''ComplianceResourceType'': ''AWS::IAM::Group'','
            - '               ''ComplianceResourceId'': ''NA'','
            - '               ''ComplianceType'': evaluate_compliance(''group''),'
            - '               ''Annotation'': ''Checks to see if AWSSupportAccess policy is assigned to IAM Group'','
            - '               ''OrderingTimestamp'': invoking_event[''notificationCreationTime'']'
            - '           },'
            - '           {'
            - '               ''ComplianceResourceType'': ''AWS::IAM::Role'','
            - '               ''ComplianceResourceId'': ''NA'','
            - '               ''ComplianceType'': evaluate_compliance(''role''),'
            - '               ''Annotation'': ''Checks to see if AWSSupportAccess policy is assigned to IAM Role'','
            - '               ''OrderingTimestamp'': invoking_event[''notificationCreationTime'']'
            - '           }'
            - '       ],'
            - '       ResultToken=event[''resultToken''])'
      Handler: index.lambda_handler
      MemorySize: 1024
      Role: !GetAtt 
        - MasterConfigRole
        - Arn
      Runtime: python2.7
      Timeout: 10
  ConfigRuleForEvaluateAwsSupportAccessPolicy:
    Type: 'AWS::Config::ConfigRule'
    DependsOn:
      - FunctionForEvaluateAwsSupportAccessPolicy
      - EvaluateAwsSupportAccessPolicyLambdaInvokePermission
      - DeliveryChannel
    Properties:
      ConfigRuleName: AwsSupportAccessPolicy
      Description: >-
        ConfigRule to evaluate whether users / groups / roles have the
        'AWSSupportAccess' policy associated - CIS 1.22 - Ensure a support role
        has been created to manage incidents with AWS Support (Scored)
      Scope:
        ComplianceResourceTypes:
          - 'AWS::IAM::User'
          - 'AWS::IAM::Group'
          - 'AWS::IAM::Role'
      Source:
        Owner: CUSTOM_LAMBDA
        SourceDetails:
          - EventSource: aws.config
            MessageType: ConfigurationItemChangeNotification
        SourceIdentifier: !GetAtt 
          - FunctionForEvaluateAwsSupportAccessPolicy
          - Arn
  EvaluateFullAdminPrivilegesPoliciesLambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    DependsOn: FunctionForEvaluateFullAdminPrivilegesPolicies
    Properties:
      FunctionName: !GetAtt 
        - FunctionForEvaluateFullAdminPrivilegesPolicies
        - Arn
      Action: 'lambda:InvokeFunction'
      Principal: config.amazonaws.com
  FunctionForEvaluateFullAdminPrivilegesPolicies:
    Type: 'AWS::Lambda::Function'
    DependsOn:
      - MasterConfigRole
    Properties:
      FunctionName: EvaluateFullAdminPrivilegesPolicies
      Description: >-
        Evaluates whether policies allowing full admin privileges '*:*' have
        been created
      Code:
        ZipFile: !Join 
          - |+

          - - import boto3
            - import json
            - import jmespath
            - 'def evaluate_compliance(config_item, policy_arn):'
            - '   if (config_item[''resourceType''] != ''AWS::IAM::Policy''):'
            - '       return ''NOT_APPLICABLE'''
            - '   return_value = ''COMPLIANT'''
            - '   client = boto3.client(''iam'')'
            - '   # Get the policy details.'
            - '   policy = client.get_policy(PolicyArn = policy_arn)[''Policy'']'
            - '   # Get the latest policy version.'
            - '   policy_version = client.get_policy_version('
            - '       PolicyArn = policy[''Arn''],'
            - '       VersionId = policy[''DefaultVersionId'']'
            - '   )'
            - '   if jmespath.search(''PolicyVersion.Document.Statement[?Effect == \''Allow\'' && contains(Resource, \''*\'') && contains (Action, \''*\'')]'', policy_version):'
            - '       return_value = ''NON_COMPLIANT'''
            - '   return return_value'
            - 'def lambda_handler(event, context):'
            - '   invoking_event = json.loads(event[''invokingEvent''])'
            - '   policy_arn = invoking_event[''configurationItem''][''ARN'']'
            - '   compliance_value = evaluate_compliance(invoking_event[''configurationItem''], policy_arn)'
            - '   config = boto3.client(''config'')'
            - '   response = config.put_evaluations('
            - '       Evaluations=['
            - '           {'
            - '               ''ComplianceResourceType'': invoking_event[''configurationItem''][''resourceType''],'
            - '               ''ComplianceResourceId'': invoking_event[''configurationItem''][''resourceId''],'
            - '               ''ComplianceType'': compliance_value,'
            - '               ''Annotation'' : ''Evaluates whether the customer managed policy is allowing full admin privileges - *:*'','
            - '               ''OrderingTimestamp'': invoking_event[''configurationItem''][''configurationItemCaptureTime'']'
            - '           },'
            - '       ],'
            - '       ResultToken=event[''resultToken''])'
      Handler: index.lambda_handler
      MemorySize: 1024
      Role: !GetAtt 
        - MasterConfigRole
        - Arn
      Runtime: python2.7
      Timeout: 10
  ConfigRuleForEvaluateFullAdminPrivilegesPolicies:
    Type: 'AWS::Config::ConfigRule'
    DependsOn:
      - FunctionForEvaluateFullAdminPrivilegesPolicies
      - EvaluateFullAdminPrivilegesPoliciesLambdaInvokePermission
      - DeliveryChannel
    Properties:
      ConfigRuleName: EvaluateFullAdminPrivilegesPolicies
      Description: >-
        ConfigRule to evaluate whether policies allowing full admin privileges
        '*:*' have been created - CIS 1.24 - Ensure IAM policies that allow full
        '*:*' administrative privileges are not created (Scored)
      Scope:
        ComplianceResourceTypes:
          - 'AWS::IAM::Policy'
      Source:
        Owner: CUSTOM_LAMBDA
        SourceDetails:
          - EventSource: aws.config
            MessageType: ConfigurationItemChangeNotification
        SourceIdentifier: !GetAtt 
          - FunctionForEvaluateFullAdminPrivilegesPolicies
          - Arn
  EvaluateUnusedCredentialsLambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    DependsOn: FunctionForEvaluateUnusedCredentials
    Properties:
      FunctionName: !GetAtt 
        - FunctionForEvaluateUnusedCredentials
        - Arn
      Action: 'lambda:InvokeFunction'
      Principal: config.amazonaws.com
  FunctionForEvaluateUnusedCredentials:
    Type: 'AWS::Lambda::Function'
    DependsOn:
      - MasterConfigRole
    Properties:
      FunctionName: EvaluateUnusedCredentials
      Description: >-
        Evaluates whether users with password enabled have credentials unused
        for 90 days or greater
      Code:
        ZipFile: !Join 
          - |+

          - - import boto3
            - import json
            - import datetime
            - from datetime import date
            - 'APPLICABLE_RESOURCES = [''AWS::IAM::User'']'
            - DEFAULT_AGE_THRESHOLD_IN_DAYS = 90
            - 'def evaluate_compliance(configuration_item):'
            - '   if configuration_item[''resourceType''] not in APPLICABLE_RESOURCES:'
            - '       return ''NOT_APPLICABLE'''
            - '   config = boto3.client(''config'')'
            - '   resource_information = config.get_resource_config_history('
            - '       resourceType=configuration_item[''resourceType''],'
            - '       resourceId=configuration_item[''resourceId'']'
            - '       )'
            - '   user_name = resource_information[''configurationItems''][0][''resourceName'']'
            - '   now = date(datetime.date.today().year, datetime.date.today().month, datetime.date.today().day)'
            - '   iam = boto3.client(''iam'')'
            - '   user = iam.get_user(UserName=user_name)'
            - '   if user[''User''].get(''PasswordLastUsed'') is None:'
            - '       return ''NOT_APPLICABLE'''
            - '   else:'
            - '       password_last_used=user[''User''].get(''PasswordLastUsed'')'
            - '       date_last_used=date(password_last_used.year, password_last_used.month, password_last_used.day)'
            - '       age_in_days = 0'
            - '       age_in_days = (now - date_last_used).days'
            - '       if age_in_days > DEFAULT_AGE_THRESHOLD_IN_DAYS:'
            - '           return ''NON_COMPLIANT'''
            - '       else: return ''COMPLIANT'''
            - 'def lambda_handler(event, context):'
            - '   invoking_event = json.loads(event[''invokingEvent''])'
            - '   configuration_item = invoking_event[''configurationItem'']'
            - '   result_token = ''No token found.'''
            - '   if ''resultToken'' in event:'
            - '       result_token = event[''resultToken'']'
            - '   config = boto3.client(''config'')'
            - '   config.put_evaluations('
            - '       Evaluations=['
            - '           {'
            - '               ''ComplianceResourceType'' : configuration_item[''resourceType''],'
            - '               ''ComplianceResourceId'' : configuration_item[''resourceId''],'
            - '               ''ComplianceType'' : evaluate_compliance(configuration_item),'
            - '               ''Annotation'' : ''Evaluates whether users with password enabled have credentials unused for 90 days or greater'','
            - '               ''OrderingTimestamp'' : configuration_item[''configurationItemCaptureTime'']'
            - '           },'
            - '       ],'
            - '       ResultToken=result_token'
            - '   )'
      Handler: index.lambda_handler
      MemorySize: 1024
      Role: !GetAtt 
        - MasterConfigRole
        - Arn
      Runtime: python2.7
      Timeout: 10
  ConfigRuleForEvaluateUnusedCredentials:
    Type: 'AWS::Config::ConfigRule'
    DependsOn:
      - FunctionForEvaluateUnusedCredentials
      - EvaluateUnusedCredentialsLambdaInvokePermission
      - DeliveryChannel
    Properties:
      ConfigRuleName: EvaluateUnusedCredentials
      Description: >-
        ConfigRule to evaluate whether users with password enabled have
        credentials unused for 90 days or greater - CIS 1.3 - Ensure credentials
        unused for 90 days or greater are disabled (Scored)
      Scope:
        ComplianceResourceTypes:
          - 'AWS::IAM::User'
      Source:
        Owner: CUSTOM_LAMBDA
        SourceDetails:
          - EventSource: aws.config
            MessageType: ConfigurationItemChangeNotification
        SourceIdentifier: !GetAtt 
          - FunctionForEvaluateUnusedCredentials
          - Arn
  EvaluateAccessKeysLambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    DependsOn: FunctionForEvaluateAccessKeys
    Properties:
      FunctionName: !GetAtt 
        - FunctionForEvaluateAccessKeys
        - Arn
      Action: 'lambda:InvokeFunction'
      Principal: config.amazonaws.com
  FunctionForEvaluateAccessKeys:
    Type: 'AWS::Lambda::Function'
    DependsOn:
      - MasterConfigRole
    Properties:
      FunctionName: EvaluateAccessKeys
      Description: >-
        Evaluates whether users have unused active access keys for 90 days or
        greater
      Code:
        ZipFile: !Join 
          - |+

          - - import boto3
            - import json
            - import datetime
            - from datetime import date
            - 'APPLICABLE_RESOURCES = [''AWS::IAM::User'']'
            - DEFAULT_AGE_THRESHOLD_IN_DAYS = 90
            - 'def evaluate_compliance(configuration_item):'
            - '   if configuration_item[''resourceType''] not in APPLICABLE_RESOURCES:'
            - '       return ''NOT_APPLICABLE'''
            - '   config = boto3.client(''config'')'
            - '   resource_information = config.get_resource_config_history('
            - '       resourceType=configuration_item[''resourceType''],'
            - '       resourceId=configuration_item[''resourceId'']'
            - '       )'
            - '   user_name = resource_information[''configurationItems''][0][''resourceName'']'
            - '   now = date(datetime.date.today().year, datetime.date.today().month, datetime.date.today().day)'
            - '   iam = boto3.client(''iam'')'
            - '   user = iam.get_user(UserName=user_name)'
            - '   for access_key in iam.list_access_keys(UserName = user_name)[''AccessKeyMetadata'']:'
            - '       if access_key[''Status''] == ''Active'':'
            - '           response = iam.get_access_key_last_used(AccessKeyId = access_key[''AccessKeyId''])'
            - '           if ''LastUsedDate'' in response[''AccessKeyLastUsed'']:'
            - '               access_key_last_used_date = response[''AccessKeyLastUsed''][''LastUsedDate'']'
            - '               access_key_last_used_date = date(access_key_last_used_date.year, access_key_last_used_date.month, access_key_last_used_date.day)'
            - '               age_in_days = 0'
            - '               age_in_days = (now - access_key_last_used_date).days'
            - '               if age_in_days > DEFAULT_AGE_THRESHOLD_IN_DAYS:'
            - '                   return ''NON_COMPLIANT'''
            - '               else: return ''COMPLIANT'''
            - 'def lambda_handler(event, context):'
            - '   invoking_event = json.loads(event[''invokingEvent''])'
            - '   configuration_item = invoking_event[''configurationItem'']'
            - '   result_token = ''No token found.'''
            - '   if ''resultToken'' in event:'
            - '       result_token = event[''resultToken'']'
            - '   config = boto3.client(''config'')'
            - '   config.put_evaluations('
            - '       Evaluations=['
            - '           {'
            - '               ''ComplianceResourceType'' : configuration_item[''resourceType''],'
            - '               ''ComplianceResourceId'' : configuration_item[''resourceId''],'
            - '               ''ComplianceType'' : evaluate_compliance(configuration_item),'
            - '               ''Annotation'' : ''Evaluates whether users have unused active access keys for 90 days or greater'','
            - '               ''OrderingTimestamp'' : configuration_item[''configurationItemCaptureTime'']'
            - '           },'
            - '       ],'
            - '       ResultToken=result_token'
            - '   )'
      Handler: index.lambda_handler
      MemorySize: 1024
      Role: !GetAtt 
        - MasterConfigRole
        - Arn
      Runtime: python2.7
      Timeout: 10
  ConfigRuleForEvaluateAccessKeys:
    Type: 'AWS::Config::ConfigRule'
    DependsOn:
      - FunctionForEvaluateAccessKeys
      - EvaluateAccessKeysLambdaInvokePermission
      - DeliveryChannel
    Properties:
      ConfigRuleName: EvaluateAccessKeys
      Description: >-
        ConfigRule to evaluate whether users have unused active access keys for
        90 days or greater - CIS 1.4 - Ensure access keys are rotated every 90
        days or less (Scored)
      Scope:
        ComplianceResourceTypes:
          - 'AWS::IAM::User'
      Source:
        Owner: CUSTOM_LAMBDA
        SourceDetails:
          - EventSource: aws.config
            MessageType: ConfigurationItemChangeNotification
        SourceIdentifier: !GetAtt 
          - FunctionForEvaluateAccessKeys
          - Arn
  EvaluateCloudTrailLoggingLambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    DependsOn: FunctionForEvaluateCloudTrailLogging
    Properties:
      FunctionName: !GetAtt 
        - FunctionForEvaluateCloudTrailLogging
        - Arn
      Action: 'lambda:InvokeFunction'
      Principal: config.amazonaws.com
  FunctionForEvaluateCloudTrailLogging:
    Type: 'AWS::Lambda::Function'
    DependsOn:
      - MasterConfigRole
    Properties:
      FunctionName: EvaluateCloudTrailLogging
      Description: Evaluates whether access logging is enabled on the CloudTrail S3 bucket
      Code:
        ZipFile: !Join 
          - |+

          - - import json
            - import boto3
            - import datetime
            - import time
            - 'def lambda_handler(event, context):'
            - '   annotation = '''''
            - '   s3_bucket_name = '''''
            - '   is_compliant = True'
            - '   client_ct = boto3.client(''cloudtrail'')'
            - '   for trail in client_ct.describe_trails(includeShadowTrails = False)[''trailList'']:'
            - '       if trail[''S3BucketName'']:'
            - '           s3_bucket_name = trail[''S3BucketName'']'
            - '           client_s=boto3.client(''s3'')'
            - '           response = client_s.get_bucket_logging(Bucket = s3_bucket_name)'
            - '           if ''LoggingEnabled'' not in response:'
            - '               is_compliant=False'
            - '               annotation = annotation + '' The CloudTrail S3 bucket \''{}\'' does not have logging enabled.''.format(s3_bucket_name)'
            - '           else:'
            - '               annotation = annotation + '' CloudTrail is not integrated with S3.'''
            - '   result_token = ''No token found.'''
            - '   if ''resultToken'' in event: result_token = event[''resultToken'']'
            - '   evaluations = ['
            - '       {'
            - '           ''ComplianceResourceType'': ''AWS::S3::Bucket'','
            - '           ''ComplianceResourceId'': s3_bucket_name,'
            - '           ''ComplianceType'': ''COMPLIANT'' if is_compliant else ''NON_COMPLIANT'','
            - '           ''OrderingTimestamp'': datetime.datetime.now()'
            - '       }'
            - '   ]'
            - '   if is_compliant: annotation = ''Acces logging is enabled on the CloudTrail S3 bucket'''
            - '   if annotation: evaluations[0][''Annotation''] = annotation'
            - '   config = boto3.client(''config'')'
            - '   config.put_evaluations('
            - '       Evaluations = evaluations,'
            - '       ResultToken = result_token'
            - '   )'
      Handler: index.lambda_handler
      MemorySize: 1024
      Role: !GetAtt 
        - MasterConfigRole
        - Arn
      Runtime: python2.7
      Timeout: 10
  ConfigRuleForEvaluateCloudTrailLogging:
    Type: 'AWS::Config::ConfigRule'
    DependsOn:
      - FunctionForEvaluateCloudTrailLogging
      - EvaluateCloudTrailLoggingLambdaInvokePermission
      - DeliveryChannel
    Properties:
      ConfigRuleName: EvaluateCloudTrailLogging
      Description: >-
        ConfigRule to evaluate whether access logging is enabled on the
        CloudTrail S3 bucket - CIS 2.6 - Ensure S3 Bucket Access Logging is
        enabled on the CloudTrail S3 bucket (Scored)
      Scope:
        ComplianceResourceTypes:
          - 'AWS::CloudTrail::Trail'
      Source:
        Owner: CUSTOM_LAMBDA
        SourceDetails:
          - EventSource: aws.config
            MessageType: ConfigurationItemChangeNotification
        SourceIdentifier: !GetAtt 
          - FunctionForEvaluateCloudTrailLogging
          - Arn
  EvaluateCloudTrailLogsEncryptionLambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    DependsOn: FunctionForEvaluateCloudTrailLogsEncryption
    Properties:
      FunctionName: !GetAtt 
        - FunctionForEvaluateCloudTrailLogsEncryption
        - Arn
      Action: 'lambda:InvokeFunction'
      Principal: config.amazonaws.com
  FunctionForEvaluateCloudTrailLogsEncryption:
    Type: 'AWS::Lambda::Function'
    DependsOn:
      - MasterConfigRole
    Properties:
      FunctionName: EvaluateCloudTrailLogsEncryption
      Description: Evaluates whether CloudTrail logs are encrypted at rest
      Code:
        ZipFile: !Join 
          - |+

          - - import json
            - import boto3
            - import datetime
            - import time
            - 'def lambda_handler(event, context):'
            - '   is_compliant = True'
            - '   annotation = '''''
            - '   current_region_trail = {}'
            - '   client_ct = boto3.client(''cloudtrail'')'
            - '   for trail in client_ct.describe_trails()[''trailList'']:'
            - '       if trail[''HomeRegion''] == context.invoked_function_arn.split('':'')[3]:'
            - '           current_region_trail = trail'
            - '   if not ''KmsKeyId'' in current_region_trail:'
            - '       is_compliant = False'
            - '       annotation = annotation + '' CloudTrail log files are not encrypted in S3.'''
            - '   result_token = ''No token found.'''
            - '   if ''resultToken'' in event: result_token = event[''resultToken'']'
            - '   evaluations = ['
            - '       {'
            - '           ''ComplianceResourceType'': ''AWS::CloudTrail::Trail'','
            - '           ''ComplianceResourceId'': current_region_trail[''Name''],'
            - '           ''ComplianceType'': ''COMPLIANT'' if is_compliant else ''NON_COMPLIANT'','
            - '           ''OrderingTimestamp'': datetime.datetime.now()'
            - '       }'
            - '   ]'
            - '   if is_compliant: annotation = ''CloudTrail log files are encrypted in S3'''
            - '   if annotation: evaluations[0][''Annotation''] = annotation'
            - '   config = boto3.client(''config'')'
            - '   config.put_evaluations('
            - '       Evaluations = evaluations,'
            - '       ResultToken = result_token'
            - '   )'
      Handler: index.lambda_handler
      MemorySize: 1024
      Role: !GetAtt 
        - MasterConfigRole
        - Arn
      Runtime: python2.7
      Timeout: 10
  ConfigRuleForEvaluateCloudTrailLogsEncryption:
    Type: 'AWS::Config::ConfigRule'
    DependsOn:
      - FunctionForEvaluateCloudTrailLogsEncryption
      - EvaluateCloudTrailLogsEncryptionLambdaInvokePermission
      - DeliveryChannel
    Properties:
      ConfigRuleName: EvaluateCloudTrailLogsEncryption
      Description: >-
        ConfigRule to evaluate whether CloudTrail logs are encrypted at rest -
        CIS 2.7 - Ensure CloudTrail logs are encrypted at rest using KMS CMKs
        (Scored)
      Scope:
        ComplianceResourceTypes:
          - 'AWS::CloudTrail::Trail'
      Source:
        Owner: CUSTOM_LAMBDA
        SourceDetails:
          - EventSource: aws.config
            MessageType: ConfigurationItemChangeNotification
        SourceIdentifier: !GetAtt 
          - FunctionForEvaluateCloudTrailLogsEncryption
          - Arn
  EvaluateCMKsRotationLambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    DependsOn: FunctionForEvaluateCMKsRotation
    Properties:
      FunctionName: !GetAtt 
        - FunctionForEvaluateCMKsRotation
        - Arn
      Action: 'lambda:InvokeFunction'
      Principal: config.amazonaws.com
  FunctionForEvaluateCMKsRotation:
    Type: 'AWS::Lambda::Function'
    DependsOn:
      - MasterConfigRole
    Properties:
      FunctionName: EvaluateCMKsRotation
      Description: >-
        Evaluates whether existing customer managed keys (CMKs) have key
        rotation enabled
      Code:
        ZipFile: !Join 
          - |+

          - - import boto3
            - import json
            - import datetime
            - 'def lambda_handler(event, context):'
            - '   is_compliant = True'
            - '   result_token = ''No token found.'''
            - '   annotation = '''''
            - '   compliance_resource_type = ''N/A'''
            - '   if ''resultToken'' in event: result_token = event[''resultToken'']'
            - '   evaluations = []'
            - '   kms_client = boto3.client(''kms'')'
            - '   config_client = boto3.client(''config'')'
            - '   aws_managed_keys = []'
            - '   for key in kms_client.list_aliases()[''Aliases'']:'
            - '       if ''TargetKeyId'' in key and key[''AliasName''].startswith(''alias/aws''):'
            - '           aws_managed_keys.append(key[''TargetKeyId''])'
            - '   if key not in kms_client.list_keys()[''Keys'']:'
            - '       evaluations.append('
            - '           {'
            - '               ''ComplianceResourceType'': ''AWS::KMS::Key'','
            - '               ''ComplianceResourceId'': ''NA'','
            - '               ''ComplianceType'': ''NON_COMPLIANT'','
            - '               ''Annotation'': ''No CMKs found have been found'','
            - '               ''OrderingTimestamp'': datetime.datetime.now()'
            - '           }'
            - '       )'
            - '   for key in kms_client.list_keys()[''Keys'']:'
            - '       if not key[''KeyId''] in aws_managed_keys:'
            - '           try:'
            - '               is_compliant = kms_client.get_key_rotation_status(KeyId = key[''KeyId''])[''KeyRotationEnabled'']'
            - '           except:'
            - '               is_compliant = True'
            - '       if is_compliant: annotation = ''Key rotation is enabled for the specified CMK'''
            - '       else: annotation = ''Key rotation is not enabled for the specified CMK'''
            - '       evaluations.append('
            - '           {'
            - '               ''ComplianceResourceType'': ''AWS::KMS::Key'','
            - '               ''ComplianceResourceId'': key[''KeyId''],'
            - '               ''ComplianceType'': ''COMPLIANT'' if is_compliant else ''NON_COMPLIANT'','
            - '               ''Annotation'': annotation,'
            - '               ''OrderingTimestamp'': datetime.datetime.now()'
            - '           }'
            - '       )'
            - '   response = config_client.put_evaluations('
            - '       Evaluations = evaluations,'
            - '       ResultToken = event[''resultToken'']'
            - '   )'
      Handler: index.lambda_handler
      MemorySize: 1024
      Role: !GetAtt 
        - MasterConfigRole
        - Arn
      Runtime: python2.7
      Timeout: 10
  ConfigRuleForEvaluateCMKsRotation:
    Type: 'AWS::Config::ConfigRule'
    DependsOn:
      - FunctionForEvaluateCMKsRotation
      - EvaluateCMKsRotationLambdaInvokePermission
      - DeliveryChannel
    Properties:
      ConfigRuleName: EvaluateCMKsRotation
      Description: >-
        ConfigRule to evaluate whether existing customer managed keys (CMKs)
        have key rotation enabled - CIS 2.8 - Ensure rotation for customer
        created CMKs is enabled (Scored)
      Scope:
        ComplianceResourceTypes:
          - 'AWS::KMS::Key'
      Source:
        Owner: CUSTOM_LAMBDA
        SourceDetails:
          - EventSource: aws.config
            MessageType: ScheduledNotification
            MaximumExecutionFrequency: One_Hour
        SourceIdentifier: !GetAtt 
          - FunctionForEvaluateCMKsRotation
          - Arn
  ConfigRuleForEvaluateSecurityGroupsSsh:
    Type: 'AWS::Config::ConfigRule'
    DependsOn:
      - DeliveryChannel
    Properties:
      ConfigRuleName: EvaluateSecurityGroupsSsh
      Description: >-
        ConfigRule to evaluate whether security groups that are in use disallow
        unrestricted incoming SSH traffic - CIS 4.1 - Ensure no security groups
        allow ingress from 0.0.0.0/0 to port 22 (Scored)
      Scope:
        ComplianceResourceTypes:
          - 'AWS::EC2::SecurityGroup'
      Source:
        Owner: AWS
        SourceIdentifier: INCOMING_SSH_DISABLED
  ConfigRuleForEvaluateSecurityGroupsRdp:
    Type: 'AWS::Config::ConfigRule'
    DependsOn:
      - DeliveryChannel
    Properties:
      ConfigRuleName: EvaluateSecurityGroupsRdp
      Description: >-
        ConfigRule to evaluate whether security groups that are in use disallow
        unrestricted incoming RDP traffic - CIS 4.2 - Ensure no security groups
        allow ingress from 0.0.0.0/0 to port 3389 (Scored)
      InputParameters:
        blockedPort1: '3389'
      Scope:
        ComplianceResourceTypes:
          - 'AWS::EC2::SecurityGroup'
      Source:
        Owner: AWS
        SourceIdentifier: RESTRICTED_INCOMING_TRAFFIC
  EvaluateVpcFlowLogsLambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    DependsOn: FunctionForEvaluateVpcFlowLogs
    Properties:
      FunctionName: !GetAtt 
        - FunctionForEvaluateVpcFlowLogs
        - Arn
      Action: 'lambda:InvokeFunction'
      Principal: config.amazonaws.com
  FunctionForEvaluateVpcFlowLogs:
    Type: 'AWS::Lambda::Function'
    DependsOn:
      - MasterConfigRole
    Properties:
      FunctionName: EvaluateVpcFlowLogs
      Description: Evaluates whether VPC flow logging is enabled
      Code:
        ZipFile: !Join 
          - |+

          - - import boto3
            - import json
            - 'def evaluate_compliance(config_item, vpc_id):'
            - '   if (config_item[''resourceType''] != ''AWS::EC2::VPC''):'
            - '       return ''NOT_APPLICABLE'''
            - '   elif is_flow_logs_enabled(vpc_id):'
            - '       return ''COMPLIANT'''
            - '   else:'
            - '       return ''NON_COMPLIANT'''
            - 'def is_flow_logs_enabled(vpc_id):'
            - '   ec2 = boto3.client(''ec2'')'
            - '   response = ec2.describe_flow_logs('
            - '       Filter=['
            - '           {'
            - '               ''Name'': ''resource-id'','
            - '               ''Values'': [vpc_id,]'
            - '           },'
            - '       ],'
            - '   )'
            - '   if response[''FlowLogs'']:'
            - '       return True'
            - 'def lambda_handler(event, context):'
            - '   invoking_event = json.loads(event[''invokingEvent''])'
            - '   compliance_value = ''NOT_APPLICABLE'''
            - '   vpc_id = invoking_event[''configurationItem''][''resourceId'']'
            - '   compliance_value = evaluate_compliance(invoking_event[''configurationItem''], vpc_id)'
            - '   config = boto3.client(''config'')'
            - '   response = config.put_evaluations('
            - '       Evaluations=['
            - '           {'
            - '               ''ComplianceResourceType'': invoking_event[''configurationItem''][''resourceType''],'
            - '               ''ComplianceResourceId'': vpc_id,'
            - '               ''ComplianceType'': compliance_value,'
            - '               ''Annotation'' : ''Evaluates whether VPC flow logging is enabled'','
            - '               ''OrderingTimestamp'': invoking_event[''configurationItem''][''configurationItemCaptureTime'']'
            - '           },'
            - '       ],'
            - '       ResultToken=event[''resultToken''])'
      Handler: index.lambda_handler
      MemorySize: 1024
      Role: !GetAtt 
        - MasterConfigRole
        - Arn
      Runtime: python2.7
      Timeout: 10
  ConfigRuleForEvaluateVpcFlowLogs:
    Type: 'AWS::Config::ConfigRule'
    DependsOn:
      - FunctionForEvaluateVpcFlowLogs
      - EvaluateVpcFlowLogsLambdaInvokePermission
      - DeliveryChannel
    Properties:
      ConfigRuleName: EvaluateVpcFlowLogs
      Description: >-
        ConfigRule to evaluate whether VPC flow logging is enabled - CIS 4.3 -
        Ensure VPC flow logging is enabled in all VPCs (Scored)
      Scope:
        ComplianceResourceTypes:
          - 'AWS::EC2::VPC'
      Source:
        Owner: CUSTOM_LAMBDA
        SourceDetails:
          - EventSource: aws.config
            MessageType: ConfigurationItemChangeNotification
        SourceIdentifier: !GetAtt 
          - FunctionForEvaluateVpcFlowLogs
          - Arn
  EvaluateDefaultSecurityGroupLambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    DependsOn: FunctionForEvaluateDefaultSecurityGroup
    Properties:
      FunctionName: !GetAtt 
        - FunctionForEvaluateDefaultSecurityGroup
        - Arn
      Action: 'lambda:InvokeFunction'
      Principal: config.amazonaws.com
  FunctionForEvaluateDefaultSecurityGroup:
    Type: 'AWS::Lambda::Function'
    DependsOn:
      - MasterConfigRole
    Properties:
      FunctionName: EvaluateDefaultSecurityGroup
      Description: Evaluates whether VPC default security groups restrict all traffic
      Code:
        ZipFile: !Join 
          - |+

          - - import boto3
            - import json
            - 'def lambda_handler(event, context):'
            - '   is_compliant = True'
            - '   invoking_event = json.loads(event[''invokingEvent''])'
            - '   annotation = '''''
            - '   security_group_id = invoking_event[''configurationItem''][''resourceId'']'
            - '   security_group = boto3.client(''ec2'').describe_security_groups(GroupIds=[security_group_id])[''SecurityGroups'']'
            - '   if security_group[0][''GroupName''] == ''default'':'
            - '       if security_group[0][''IpPermissions'']:'
            - '           annotation = annotation + ''The security group has ingress rules in place.'''
            - '           is_compliant = False'
            - '       if security_group[0][''IpPermissionsEgress'']:'
            - '           annotation = annotation + '' The security group has egress rules in place.'''
            - '           is_compliant = False'
            - '       evaluations = ['
            - '           {'
            - '               ''ComplianceResourceType'': invoking_event[''configurationItem''][''resourceType''],'
            - '               ''ComplianceResourceId'': security_group_id,'
            - '               ''ComplianceType'': ''COMPLIANT'' if is_compliant else ''NON_COMPLIANT'','
            - '               ''OrderingTimestamp'': invoking_event[''configurationItem''][''configurationItemCaptureTime'']'
            - '           }'
            - '       ]'
            - '       if annotation: evaluations[0][''Annotation''] = annotation'
            - '       response = boto3.client(''config'').put_evaluations('
            - '           Evaluations = evaluations,'
            - '           ResultToken = event[''resultToken''])'
      Handler: index.lambda_handler
      MemorySize: 1024
      Role: !GetAtt 
        - MasterConfigRole
        - Arn
      Runtime: python2.7
      Timeout: 10
  ConfigRuleForEvaluateDefaultSecurityGroup:
    Type: 'AWS::Config::ConfigRule'
    DependsOn:
      - FunctionForEvaluateDefaultSecurityGroup
      - EvaluateVpcFlowLogsLambdaInvokePermission
      - DeliveryChannel
    Properties:
      ConfigRuleName: EvaluateDefaultSecurityGroup
      Description: >-
        ConfigRule to evaluate whether VPC default security groups restrict all
        traffic - CIS 4.4 - Ensure the default security group of every VPC
        restricts all traffic (Scored)
      Scope:
        ComplianceResourceTypes:
          - 'AWS::EC2::SecurityGroup'
      Source:
        Owner: CUSTOM_LAMBDA
        SourceDetails:
          - EventSource: aws.config
            MessageType: ConfigurationItemChangeNotification
        SourceIdentifier: !GetAtt 
          - FunctionForEvaluateDefaultSecurityGroup
          - Arn
          
#===============================================================================================================================
# Password Policy Section
#===============================================================================================================================
  LambdaRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Path: /
      Policies:
        - PolicyName: logs
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: 'arn:aws:logs:*:*:*'
        - PolicyName: iam
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - 'iam:UpdateAccountPasswordPolicy'
                  - 'iam:DeleteAccountPasswordPolicy'
                Resource: '*'
  LambdaFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        ZipFile: !Join 
          - ''
          - - |
              var AWS = require('aws-sdk'); 
            - |
              var response = require('cfn-response'); 
            - |
              var iam = new AWS.IAM(); 
            - |
              exports.handler = function(event, context, cb) {
            - |
              console.log('Invoke: ' + JSON.stringify(event));
            - |
              function done(err) {
            - |
              if (err) {
            - |
              console.log('Error: ' + JSON.stringify(err));
            - |
              response.send(event, context, response.FAILED, {});
            - |
              } else {
            - |
              response.send(event, context, response.SUCCESS, {});
            - |
              }
            - |
              }
            - |
              if (event.RequestType === 'Delete') {
            - |
              iam.deleteAccountPasswordPolicy({}, done);
            - >
              } else if (event.RequestType === 'Create' || event.RequestType ===
              'Update') {
            - |
              iam.updateAccountPasswordPolicy({ 
            - 'AllowUsersToChangePassword: '
            - !Ref AllowUsersToChangePassword
            - |
              ,
            - 'HardExpiry: '
            - !Ref HardExpiry
            - |
              ,
            - 'MaxPasswordAge: '
            - !Ref MaxPasswordAge
            - |
              ,
            - 'MinimumPasswordLength: '
            - !Ref MinimumPasswordLength
            - |
              ,
            - 'PasswordReusePrevention: '
            - !Ref PasswordReusePrevention
            - |
              ,
            - 'RequireLowercaseCharacters: '
            - !Ref RequireLowercaseCharacters
            - |
              ,
            - 'RequireNumbers: '
            - !Ref RequireNumbers
            - |
              ,
            - 'RequireSymbols: '
            - !Ref RequireSymbols
            - |
              ,
            - 'RequireUppercaseCharacters: '
            - !Ref RequireUppercaseCharacters
            - |+

            - |
              }, done);
            - |
              } else {
            - |
              cb(new Error('unsupported RequestType: ' + event.RequestType));
            - |
              }
            - '};'
      Handler: index.handler
      MemorySize: 128
      Role: !GetAtt 
        - LambdaRole
        - Arn
      Runtime: nodejs4.3
      Timeout: 60
  PasswordPolicy:
    Type: 'Custom::PasswordPolicy'
    Version: '1.0'
    Properties:
      ServiceToken: !GetAtt 
        - LambdaFunction
        - Arn
#===============================================================================================================================
# 
#===============================================================================================================================